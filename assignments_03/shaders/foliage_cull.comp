#version 430 core

layout(local_size_x = 256) in;

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

struct RawInstanceProperties {
    vec4 position;
    ivec4 indices;
};

struct InstanceProperties {
    vec4 position;
};

layout(std430, binding = 0) buffer RawInstanceData {
    RawInstanceProperties rawInstanceProps[];
};

layout(std430, binding = 1) buffer CurrValidInstanceData {
    InstanceProperties currValidInstanceProps[];
};

layout(std430, binding = 2) buffer DrawCommandsBlock {
    DrawCommand commands[];
};

layout(std430, binding = 3) buffer InstanceStateBlock {
    uint instanceStates[];
};

uniform mat4 playerView;
uniform mat4 playerProj;
uniform uint totalInstanceCount;
uniform int numMeshes;
uniform float eraseRadius;
uniform vec3 slimePosition;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= totalInstanceCount) {
        return;
    }

    if (instanceStates[idx] == 1u) {
        return;
    }

    RawInstanceProperties raw = rawInstanceProps[idx];
    float distanceToSlime = distance(raw.position.xyz, slimePosition);
    if (distanceToSlime < eraseRadius) {
        instanceStates[idx] = 1u;
        return;
    }

    vec4 viewPos = playerView * vec4(raw.position.xyz, 1.0);
    vec4 clipPos = playerProj * viewPos;
    float w = clipPos.w;
    if (w <= 0.0) {
        return;
    }
    vec3 ndc = clipPos.xyz / w;
    if (any(greaterThan(abs(ndc), vec3(1.0)))) {
        return;
    }

    int meshID = raw.indices.x;
    if (meshID < 0 || meshID >= numMeshes) {
        return;
    }

    uint localIndex = atomicAdd(commands[meshID].instanceCount, 1u);
    uint dstIndex = commands[meshID].baseInstance + localIndex;
    currValidInstanceProps[dstIndex].position = raw.position;
}
